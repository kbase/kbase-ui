#
# A minimal proxying configuration for running kbase-ui through a secure proxy
# against a KBase deploy environment.
#
# Note that lower case environment variables are taken from conf/*.env, where * is the 
# deploy environment, taken from DEPLOY_ENV.

# Environment Variables:
# BASE_PATH = {{ .Env.BASE_PATH }}
# UI_DOMAIN = {{ .Env.UI_DOMAIN }}
# KBASE_UI_DOMAIN = {{ .Env.KBASE_UI_DOMAIN }}
# KBASE_UI_HOST = {{ .Env.KBASE_UI_HOST }} 
# EUROPA_UI_HOST = {{ .Env.EUROPA_UI_HOST }}
# LOCAL_NARRATIVE = {{ .Env.LOCAL_NARRATIVE }}
# SERVICE_PROXIES = {{ .Env.SERVICE_PROXIES }}
# DYNAMIC_SERVICE_PROXIES = {{ .Env.DYNAMIC_SERVICE_PROXIES }}
# SERVICES_DOMAIN = {{ .Env.SERVICES_DOMAIN }}



{{ $subhost := not (eq .Env.UI_DOMAIN .Env.KBASE_UI_DOMAIN) }}

{{ if $subhost }}
# Configured for SUBHOST {{ .Env.KBASE_UI_DOMAIN }}
{{ else }}
# Configured for SAME HOST
{{ end }}

daemon off;
error_log /dev/stdout info;
worker_processes auto;
pid /var/run/nginx.pid;

events {
	worker_connections 1024;
}

http {
	sendfile on;
	tcp_nopush on;
	tcp_nodelay on;
	types_hash_max_size 2048;
    proxy_headers_hash_bucket_size 256;
    proxy_ssl_server_name on;
    proxy_request_buffering off;
    proxy_buffering off;
    proxy_http_version 1.1;

    # In addition to the desired file size limit (in bytes),
    # we ad  smidgen more, as the multipart/form mime structure 
    # includes the destPath as one part, the file as another, 
    # and each has a small header section.
    # 
    # In practice, this appears to be about 300 bytes plus 
    # the value for destPath and the file name.
    # And the mime boundary size will vary as well.
    #
    # So let's call it 1K and then call it a day.
    # So, the max body size should be MAX_FILE_SIZE + 1000.

    # For testing, use a 1K file size, 1K extra.
    # Or set as you wish to push boundaries.
    # client_max_body_size 2000;

    # For production, 5G max file size plus 1KB extra.
    # client_max_body_size 5000001000;

    keepalive_requests 0;
	# keepalive_timeout 65;
    keepalive_timeout 0;

	include /etc/nginx/mime.types;
	default_type application/octet-stream;

    map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
    }

    upstream kbase_ui {
        server {{ .Env.KBASE_UI_HOST }}:3000;
        # allows the proxy to start up even though the 
        # target may not be running yet
        server {{ .Env.KBASE_UI_HOST }}:80 backup;
        keepalive 16;
    }

     upstream europa_ui {
        server {{ .Env.EUROPA_UI_HOST }}:8080;
        # allows the proxy to start up even though the 
        # target may not be running yet
        server {{ .Env.EUROPA_UI_HOST }}:80 backup;
        keepalive 16;
    }

    upstream narrative {
        {{ if eq .Env.LOCAL_NARRATIVE "t" }}
            server narrative:8888;
        {{ else }}
            server {{ .Env.UI_DOMAIN }};
        {{ end }}
    }

    log_format upstream_log '[$time_local] $remote_addr - $remote_user - $server_name to: $upstream_addr: $request upstream_response_time $upstream_response_time proxy_host $proxy_host upstream_status $upstream_status upstream_response_length $upstream_response_length upstream_http_location $upstream_http_location msec $msec request_time $request_time http_origin $http_origin';

	# Logging Settings
	access_log /var/log/nginx/access.log;
	error_log /var/log/nginx/error.log debug;

    # Route insecure requests to secure.
    server {
        listen 80 default_server;
        listen [::]:80 default_server;
        server_name {{ .Env.UI_DOMAIN }};
        return 301 https://{{ .Env.UI_DOMAIN }}$request_uri;
    }

     server {
        server_name {{ .Env.UI_DOMAIN }};
        listen 443 ssl;
        ssl_certificate /kb/deployment/ssl/test.crt;
        ssl_certificate_key /kb/deployment/ssl/test.key;
        ssl_protocols TLSv1.2 TLSv1.1 TLSv1;

        location @request_entity_too_large {
            default_type application/json;
            # return 413 "{\"message\": \"Request entity is too large\", \"responseCode\": 413, \"maxBodySize\": \"5GB\", \"contentLength\": ${content_length}}";
            return 413 "{\"message\": \"Request entity is too large\", \"responseCode\": 413, \"maxBodySize\": \"2KB\", \"contentLength\": ${content_length}}";
        }

        keepalive_requests 0;
        keepalive_timeout 0;
        proxy_socket_keepalive off;

        # Include service and dynamic service proxying here if the ui host
        # is the same as the service host.

        # Service proxying
        # specified as a list of service modules
        # note should put the service module name in /etc/hosts and map to localhost
        {{ if .Env.SERVICE_PROXIES }}
        {{ range splitList " " .Env.SERVICE_PROXIES }}

        {{ if eq . "searchapi2" }}
            location /services/searchapi2/legacy {
                {{ if $subhost }}
                include /etc/nginx/cors.conf;
                {{ end }}
                proxy_pass http://searchapi2:5000/legacy;
                proxy_set_header Connection "";
            }
            location /services/searchapi2/rpc {
                {{ if $subhost }}
                include /etc/nginx/cors.conf;
                {{ end }}
                proxy_pass http://searchapi2:5000/rpc;
                proxy_set_header Connection "";
            }
        {{ else if eq . "staging_service" }}
            location /services/{{ . }}/ {

                # For testing, use a 1K file size, 1K extra.
                # Or set as you wish to push boundaries.
                client_max_body_size 2000;

                # For production, 5G max file size plus 1KB extra.
                # client_max_body_size 5000001000;

                error_page 413 @request_entity_too_large;

                # include /etc/nginx/cors.conf;

                proxy_pass http://{{ . }}:3000/;
                proxy_set_header Connection "";
                proxy_read_timeout 10m;
            }
        {{ else }}
            location /services/{{ . }}/ {
                {{ if $subhost }}
                include /etc/nginx/cors.conf;
                {{ end }}
                proxy_pass http://{{ . }}:5000/;
                proxy_set_header Connection "";
                proxy_read_timeout 10m;
            }
            location /services/{{ . }} {
                {{ if $subhost }}
                include /etc/nginx/cors.conf;
                {{ end }}
                proxy_pass http://{{ . }}:5000;
                proxy_set_header Connection "";
                proxy_read_timeout 10m;
            }
        {{ end }}

        {{ end }}
        {{ end }}

        # Proxy all service calls, including auth2, to the real CI
        location /services {
            access_log /var/log/nginx/services_proxy.log upstream_log;

            # need cors because kbase-ui will be on a different host.
            
            {{ if $subhost }}
            include /etc/nginx/cors.conf;
            {{ end }}

            # The cookie path rewriting is just for auth2
            proxy_cookie_path /login /services/auth/login;
            proxy_cookie_path /link /services/auth/link;
            proxy_pass https://{{ .Env.SERVICES_DOMAIN }}/services;
            proxy_set_header Connection "";
            proxy_read_timeout 10m;
        }

        # Dynamic Service proxying
        # If dynamic services are provided in the configuration, we will proxy requests
        # to them to local instances.
        # This works by trapping calls to /dynserv/XXX.Module
        # where /dynserv/ is always the path prefix for dynamic service call urls provided by
        # the service wizard
        # where XXX is a random-appearing string component provided by the service wizard
        # and Module is the dynamic service module name.

        {{ if .Env.DYNAMIC_SERVICE_PROXIES }}
        {{ range splitList " " .Env.DYNAMIC_SERVICE_PROXIES }}

        # note that the elements of the list must match the service path used in the ui call,
        # and also the hostname assigned to the docker container.
        # SO this means that probably service entries which are more complicated than simple strings
        #    without punctuation will work, but if they contain a / or something, maybe not.

        location ~ ^/dynserv/[^.]+[.]{{ . }}.*$ {
            
                {{ if $subhost }}
                include /etc/nginx/cors.conf;
                {{ end }}

            # This handles plain dynamic service calls, which don't have any path following the module name
            rewrite ^/dynserv/[^.]+[.]{{ . }}$ / break;

            # This handles calls into the dynamic service with the path is propagated.
            rewrite ^/dynserv/[^.]+[.]{{ . }}(.*)$ $1 break;
            proxy_pass http://{{ . }}:5000;
            proxy_read_timeout 10m;
        }

        {{ end }}
        {{ end }}

        # Un-trapped dynamic service calls are routed to the real dynamic service
        # endpoints.
        location /dynserv {
            # need cors because kbase-ui will be on a different host.
           
            {{ if $subhost }}
            include /etc/nginx/cors.conf;
            {{ end }}
            proxy_pass https://{{ .Env.SERVICES_DOMAIN }}/dynserv;
            proxy_set_header Connection "";
            proxy_read_timeout 10m;
        }

        location /narrative/ {
            {{ if eq .Env.LOCAL_NARRATIVE "t" }}
                proxy_pass http://narrative/narrative/;
            {{ else }}
                proxy_pass https://{{ .Env.UI_DOMAIN }}/narrative/;
            {{ end }}

            {{ if $subhost }}
            include /etc/nginx/cors.conf;
            {{ end }}

            access_log /var/log/nginx/narrative.log upstream_log;

            proxy_connect_timeout 10s;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Origin  https://{{ .Env.UI_DOMAIN }};
            proxy_set_header Host {{ .Env.UI_DOMAIN }};
        }

        location /ui-assets/ {
            proxy_pass https://{{ .Env.UI_DOMAIN }};
            proxy_set_header Connection "";
        }

        location /sn/ {
            proxy_pass https://{{ .Env.UI_DOMAIN }};
            proxy_set_header Connection "";
        }

        location /n/ {
            proxy_pass https://{{ .Env.UI_DOMAIN }};
            proxy_set_header Connection "";
        }

        # kbase-ui will be located on a path
        # disable this if the subdomain is used instead.
        # in this case, BASE_PATH had better not be empty or /.
        {{ if eq .Env.UI_DOMAIN .Env.KBASE_UI_DOMAIN }}

        {{ if .Env.BASE_PATH }}
        location /{{ .Env.BASE_PATH }}/ {
            proxy_pass http://kbase_ui;
            proxy_set_header Connection "";
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
        } 
        {{ else }}
        location / {
            proxy_pass http://kbase_ui;
            proxy_set_header Connection "";
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
        } 
        {{ end }}

        {{ end }}

        # Europa is always at the root.
        location / {
            proxy_pass http://europa_ui;
            proxy_set_header Connection "";
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
        }
    }

    # This is invoked to run kbase-ui on a subdomain if specified
    # This is de-facto always the case in the current Europa implementation.
    {{ if $subhost }}
    server {
        server_name {{ .Env.KBASE_UI_DOMAIN }};
        listen 443 ssl;
        ssl_certificate /kb/deployment/ssl/test.crt;
        ssl_certificate_key /kb/deployment/ssl/test.key;
        ssl_protocols TLSv1.2 TLSv1.1 TLSv1;

        location {{ .Env.BASE_PATH }}/ {
            include /etc/nginx/cors.conf;
            proxy_pass http://kbase_ui;
            proxy_set_header Connection "";
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
        }
    }
    {{ end }}
}
